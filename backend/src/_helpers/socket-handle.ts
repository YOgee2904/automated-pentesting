import { Server , Socket} from "socket.io";
import { performNmapScan, performZapScan, processMessage } from "./scan";
import jwt from "jsonwebtoken";
import { resolve } from "path";
import { readFileSync } from "fs";
import amqp from "amqplib/callback_api";

const privateKey = readFileSync(
  resolve(__dirname, "../keys/private_key.pem"),
  "utf8"
);

export const socketHandle = (ch: amqp.Channel, io: Server) => {
  const queue = `scan_queue`;

  io.on("connection", (socket : Socket) => {
    io.use((socket, next) => {
      const token = socket.handshake.auth.token;
      if (token) {
        jwt.verify(token, privateKey, (err: any, decoded: any) => {
          if (err) {
            return next(new Error("authentication error"));
          }
          socket.decoded = decoded.userID;
          return next();
        });
      }
      return next(new Error("authentication error"));
    });
    socket.emit("scan", "Scanning started");
    // check if the queue exists
    ch.assertQueue(queue, { durable: true });
    ch.prefetch(1);
    ch.consume(queue, (msg) => {
      socket.emit("scan", "Scanning started");
      if (msg) {
        const url = msg.content.toString();
        socket.emit("scan", "Scanning started");
        // Perform nmap scan
        performNmapScan(url, socket.decoded).then((nmapReport) => {
          socket.emit("scan", JSON.stringify(nmapReport));
          // Perform zap scan
          performZapScan(url).then((zapReport) => {
            socket.emit("scan", "Zap scan completed");
            socket.emit('scan', zapReport);
            // Save the report to the database
          });
        });
        // performZapScan(url).then((zapReport) => {
        //   socket.emit("scan", "Zap scan completed");
        //   // Save the report to the database
        // });
        // Update the status of the scan using socket for real-time status report
        // Once the status of zap reaches 100 and nmap is completed, remove the user request from the queue
        // Generate the report and send it to the user via socket
        ch.ack(msg);
      }
    });
    socket.on("disconnect", () => {
      console.log("user disconnected");
    });
  });
};
