import { Server, Socket } from "socket.io";
import { performNmapScan, performZapScan, processMessage } from "./scan";
import jwt from "jsonwebtoken";
import amqp from "amqplib/callback_api";
import { resolve } from "path";
import { readFileSync } from "fs";
import {
  getReports,
  saveReport,
  saveResult,
  updateScanStatus,
} from "./saveReport";

const privateKey = readFileSync(
  resolve(__dirname, "../keys/private_key.pem"),
  "utf8"
);
export const socketHandle = (io: Server) => {
  console.log("Socket handle");
  io.use((socket: Socket, next) => {
    const token = socket.handshake.auth.token;
    if (!token) {
      return next(new Error("Authentication error"));
    }
    jwt.verify(token, privateKey, (err: any, decoded: any) => {
      if (err) {
        console.log(err);
        return next(new Error("Authentication error"));
      }
      console.log("Decoded token:", decoded.userId);
      socket.decoded = decoded.userId;
      next();
    });
  });
  io.on("connection", (socket: Socket) => {
    console.log("Connected to server");
    socket.on("current-status", (scanData: any) => {
      console.log("Received message:", scanData.url);
      const report = getReports(scanData._id);
      report.then((data) => {
        if (data) {
          socket.emit("current-status", data);
        }
      });
    });
  });
};
export const queueProcess = (ch: amqp.Channel, msg: amqp.Message) => {
  const data = JSON.parse(msg.content.toString());
  const { url, userId } = data;
  console.log("Received message:", url);
  const queue = `scan_queue`;
  const userSockets: UserSocket = {};
  var report = {
    userId,
    url,
    status: "pending",
    nmap: false,
    zap: false,
  };

  performNmapScan(url)
    .then((data: any) => {
      const nmapReport = data[0];
      console.log(nmapReport);
      // send the nmap report to the user who initiated the scan
      report.nmap = true;
      const nmapHtml = `
      <h1>Nmap Report</h1>
      <div style="background-color: #f2f2f2; padding: 10px; margin-bottom: 10px;">
        <h2>${nmapReport.hostname}</h2>
        <p>IP: ${nmapReport.ip}</p>
        <p>MAC: ${nmapReport.mac || "N/A"}</p>
        <h3>Open Ports:</h3>
        <ul>
          ${nmapReport.openPorts
            .map(
              (port: any) => `
          <li>
        <p>Port: ${port.port}</p>
        <p>Protocol: ${port.protocol}</p>
        <p>Service: ${port.service}</p>
        <p>Method: ${port.method}</p>
          </li>
        `
            )
            .join("")}  
        </ul>
      </div>
      `;
      // zap must run even if nmap fails
      performZapScan(url)
        .then((zapReport) => {
          report.zap = true;
          const combinedHtml = `${nmapHtml}${zapReport}`;
          // path currently set to the root of the project

          report.status = "completed";
          updateScanStatus(
            userId,
            url,
            "completed",
            report.nmap,
            report.zap
          ).then((id: any) => {
            if (id) {
              saveResult(id.toString(), combinedHtml).then(() => {
                console.log("Report saved");
              });
            }
          });
        })
        .catch((error) => {
          updateScanStatus(userId, url, "failed", report.nmap, report.zap).then(
            () => {
              console.log(error);
            }
          );
        });
    })
    .catch((error) => {
      updateScanStatus(userId, url, "failed", report.nmap, report.zap).then(
        () => {
          console.log(error);
        }
      );
    });

  ch.ack(msg);
};

interface UserSocket {
  [key: string]: Socket;
}

interface INmapReport {
  hostname: string;
  ip: string;
  mac: string;
  openPorts: Array<IOpenPort>;
  osNmap: string;
}
interface IOpenPort {
  port: number;
  protocol: string;
  service: string;
  method: string;
}
