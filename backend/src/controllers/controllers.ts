import { Request, Response } from "express";
import jwt from "jsonwebtoken";
import bcrypt from "bcrypt";
import { Scan, User } from "../models/model";
import fs from "fs";
import path from "path";

import { createChannel, scan } from "../_helpers/scan";
import { create } from "domain";

const secretKey = fs.readFileSync(
  path.resolve(__dirname, "../keys/private_key.pem"),
  "utf8"
);

// Find user by email
const findUserByEmail = (email: string) => {
  const user = User.findOne({ email: email });
  return user;
};

// Login controller
export const loginController = async (req: Request, res: Response) => {
  // if token is already present, return error
  if (req.cookies.token) {
    return res.status(400).json({ message: "Already logged in" });
  }
  if (!req.body.email || !req.body.password) {
    return res.status(400).json({ message: "Email and password are required" });
  }
  const { email, password } = req.body;

  // Check if user exists in the database
  const user = await findUserByEmail(email);
  if (!user) {
    return res.status(401).json({ message: "Invalid email or password" });
  }

  // Verify the password
  const isPasswordValid = bcrypt.compareSync(password, user.password);
  if (!isPasswordValid) {
    return res.status(401).json({ message: "Invalid email or password" });
  }

  // Generate JWT token for asymmetric encryption

  const token = jwt.sign({ email: user.email, userId: user._id }, secretKey, {
    expiresIn: "24h",
    algorithm: "RS256",
  });

  // Set the token as a cookie in the response
  res.cookie("token", token, { httpOnly: true });

  // Send success response
  res.json({ uname: user.uname, email: user.email, userId: user._id });
};

// Signup controller
export const signupController = async (req: Request, res: Response) => {
  const { uname, email, password } = req.body;
  try {
    const isEmailExist = await findUserByEmail(email);
    if (isEmailExist) {
      return res.status(400).json({ message: "Email already exists" });
    }
    // create a new user from mongoose schema
    const user = new User({ uname, email, password });
    await user.save();
    res.status(201).json({ message: "User created" });
  } catch (error) {
    console.log(error);
    res.status(500).json({ message: "Internal server error" });
  }
};

// producer controller
export const scanController = async (req: Request, res: Response) => {
  const { url } = req.body;
  const { userId } = req.user;
  // do not let the user scan the same url again
  const oldScan = await Scan.findOne({
    userId,
    url,
    status: "pending",
  });
  if (oldScan) {
    return res.status(400).json({ message: "Scan already in progress" });
  }
  // create a scan report in the database
  const newScan = await new Scan({
    userId,
    url,
    status: "pending",
    result: "",
  });
  await newScan.save();
  scan("amqp://localhost", (err, conn) => {
    if (err) {
      return res.status(500).json({ message: "Error connecting to RabbitMQ" });
    }
    createChannel(conn, (err, ch) => {
      if (err) {
        return res.status(500).json({ message: "Error creating channel" });
      }
      const queue = `scan_queue`; // Use unique ID in the queue name
      const content = Buffer.from(
        JSON.stringify({ url: String(url), userId: String(userId) })
      );
      const options = { persistent: true };
      ch.assertQueue(queue, { durable: true });
      ch.sendToQueue(queue, content, options);
      res.json(newScan);
    });
  });
};

export const logoutController = async (req: Request, res: Response) => {
  res.clearCookie("token");
  res.status(201).json({ message: "Logged out" });
};

export const getUser = async (req: Request, res: Response) => {
  const { email } = req.user;
  const user = await findUserByEmail(email);
  if (!user) {
    return res.status(404).json({ message: "User not found" });
  }
  res.json({ uname: user.uname, email: user.email, userId: user._id });
};

export const getScans = async (req: Request, res: Response) => {
  const { scanId } = req.body;
  try {
    const scan = await Scan.findById(scanId);
    if (!scan) {
      return res.status(404).json({ message: "Scan not found" });
    }
    if(scan.status === "pending") {
      return res.status(400).json({ message: "Scan in progress" });
    }
    res.status(201).json(scan);
  } catch (error) {
    console.log(error);
    res.status(500).json({ message: "Internal server error" });
  }
};
